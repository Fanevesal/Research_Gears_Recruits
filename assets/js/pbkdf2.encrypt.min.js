function arrayBufferToBase64(buffer) {
    return btoa(String.fromCharCode(...new Uint8Array(buffer)));
}

function base64ToArrayBuffer(base64) {
    const binary = atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
    return bytes.buffer;
}

async function deriveKey(password, salt, round) {
    const pw = new TextEncoder().encode(password + round);
    const keyMaterial = await crypto.subtle.importKey("raw", pw, { name: "PBKDF2" }, false, ["deriveKey"]);
    return crypto.subtle.deriveKey({ name: "PBKDF2", salt: salt, iterations: 1000, hash: "SHA-256" }, keyMaterial, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]);
}

async function encrypt(text, password) {
    const salt = crypto.getRandomValues(new Uint8Array(32));
    const iv = crypto.getRandomValues(new Uint8Array(16));
    const rounds = (crypto.getRandomValues(new Uint8Array(1))[0] % 51) + 50;
    let data = new TextEncoder().encode(text);
    for (let i = 0; i < rounds; i++) {
        const key = await deriveKey(password, salt, i);
        data = new Uint8Array(await crypto.subtle.encrypt({ name: "AES-GCM", iv: iv }, key, data));
    }
    const final = new Uint8Array(1 + salt.length + iv.length + data.length);
    final[0] = rounds;
    final.set(salt, 1);
    final.set(iv, 33);
    final.set(data, 49);
    return arrayBufferToBase64(final.buffer);
}

async function decrypt(encoded, password) {
    const raw = new Uint8Array(base64ToArrayBuffer(encoded));
    const rounds = raw[0];
    const salt = raw.slice(1, 33);
    const iv = raw.slice(33, 49);
    let data = raw.slice(49);
    for (let i = rounds - 1; i >= 0; i--) {
        const key = await deriveKey(password, salt, i);
        data = new Uint8Array(await crypto.subtle.decrypt({ name: "AES-GCM", iv: iv }, key, data));
    }
    return new TextDecoder().decode(data);
}

// let texts = "OmHVrnRaEtOyBmpr2m7NcLB8VAi3xbYpxKreUeuMBhAFOtnKsChRt651ZRqdhgKp0goygiHz9yDPf50CXw2MaA6ilAEEPma9snFhPdtIFeVhawk6rnxd74dZ7mGB9h8k01zNpKbiM6+3ZJcVnWhTfkfxM/ziWmA9/F5GQVDAcUi0OBvk+5E0kcjLtzqWA1y2gmnHrpidhTF6iCziYAqxCjJK44aOkQ8Mc6zTkbApZ+v6NkdiUhV1CcM0lIlJQhGsHOvgw2MesoBshKxIaz2C1Z3JjPynqiTAmoxwDsKmHv8YgKdbw0XLSOJHbzR6ZmuDt9zndm7mYYzna1BA+bwzOh/smhMkvfzU61WQrTwYPf5kJEHkNECcoY1AJ5gtUMR3QzbkdkDKZEa9g3H7IxJBYYADfVNfqDMmfEqh37hdZt+vGlgn07hC2TEsgGeJ86wwp8qw+29WwwALQyik9vB06fZS7DldEn4W0T01QLks1IB0QSKwVzYjO09PjwNzWggENHjdWChTTjuhNNPvt0XWOJhVnuVuyLhbihPulWR8TmHMkGW25sd84n0F89xj27N7pwpArcUfhsH+UiC+oRcQAxHN2j3GSKkYdSlu47ZetjskxruRiQVb97HjQw0Rpg+bpjX1e4Vpu6R5n2dI9Ydd56xi10ThVW7Fs8j4U8tHTcVJxQdLQ5IQPLyXv30yrDtn/s4d6S2jyFg/lOs3cHVGL4T1h4OxUVP3iyzSxTj+3aGMJAQZWOs7zzzIRQg/vzQMEdOY/71/RaE4rPLfqckRGNy5004r+o3WrcxYe+LKogkD+zdMmtE0jjE+A0HPeIQUWFOhY75wE9XbvlPJ7GJFbnH2yKoxONKH+qpksq9EtJQl68/VYR+i7QdADgqrEHN8ZDeWjSxJ9a73K09TJ+gHbQfccIzxyOZGgffOuxxtUoGbsAKBJ2VCOPNekT+SSV1X4PJ8oRlld3v+NJb51xi8vGc5Nfd2WYBvwkQGOHfrqQl9SkkQwmuLlx/+PgtmJtfOBguB/+CHyc4qlNQh6t5hSwXTetGbBmfLXnwzkF9o4pY8ahKXSX8j27t+7WOHnPn8lxPwQsWhbztwMMKCL8AZv/FtNV6CEDDEasLIIAybJmLpSzUG+FAJ6jF45031GQRT40+ng6x76CE9NHgASZi6qG5kPejasnTvqN2AUc7vZRwvaGzE1a0JRKFyxZDj3xBxeKfcdD78F538spct2G65H72J706roLJrnPs7JYh05pA2Cc1/tnTGoP6p5s1ltnnY/9ETcQvo+KTYImct+WDeBRtG18K4HcM="
// decrypt(texts, "random").then(txt=>console.log(txt))